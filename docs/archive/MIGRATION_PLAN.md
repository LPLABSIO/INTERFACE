# Plan de Migration vers l'Architecture Cible

## üìç √âtat Actuel

```
INTERFACE/
‚îú‚îÄ‚îÄ HINGE/           # Logique bot m√©lang√©e
‚îú‚îÄ‚îÄ AppiumUI/        # UI ancienne
‚îú‚îÄ‚îÄ electron/        # Nouveau code UI
‚îî‚îÄ‚îÄ Fichiers config dispers√©s
```

**Probl√®mes identifi√©s:**
- Couplage fort entre UI et logique m√©tier
- Pas de s√©paration claire des responsabilit√©s
- Difficile d'ajouter de nouveaux projets
- Gestion des ports/sessions fragile
- Logs non structur√©s

## üéØ Architecture Cible

Une plateforme modulaire avec:
- **UI** d√©coupl√©e et moderne
- **Orchestrateur** central intelligent
- **Projets** isol√©s et pluggables
- **Infrastructure** robuste et scalable

## üìã √âtapes de Migration

### Phase 1: Pr√©paration (Semaine 1)
**Objectif**: Stabiliser l'existant et pr√©parer la migration

#### 1.1 Audit et Documentation
- [ ] Documenter tous les flux existants
- [ ] Identifier les d√©pendances critiques
- [ ] Lister les configurations n√©cessaires
- [ ] Cr√©er un inventaire des fonctionnalit√©s

#### 1.2 Mise en Place du Monorepo
```bash
# Structure initiale
mkdir -p AUTOMATION-PLATFORM/{UI,ORCHESTRATOR,PROJECTS,SHARED,INFRASTRUCTURE}
npm init -y # Root package.json
npx lerna init # Configuration Lerna
```

#### 1.3 Tests de Non-R√©gression
- [ ] Cr√©er des tests pour les fonctions critiques actuelles
- [ ] Documenter les comportements attendus
- [ ] √âtablir une baseline de performance

### Phase 2: Extraction des Modules (Semaine 2-3)
**Objectif**: Isoler les composants r√©utilisables

#### 2.1 Extraction du DeviceManager
```javascript
// SHARED/libs/device-manager/
class DeviceManager {
  constructor() {
    this.devices = new Map();
    this.watcher = null;
  }

  async scan() {
    // Logique extraite de main.js
  }

  async getInfo(udid) {
    // D√©tails de l'appareil
  }

  watchChanges(callback) {
    // Surveillance des connexions/d√©connexions
  }
}
```

#### 2.2 Extraction de l'AppiumManager
```javascript
// ORCHESTRATOR/src/drivers/AppiumDriver.js
class AppiumDriver {
  constructor(config) {
    this.servers = new Map();
    this.portAllocator = new PortAllocator();
  }

  async startServer(device) {
    const port = await this.portAllocator.allocate();
    // D√©marrage Appium avec gestion d'erreurs
  }

  async createSession(device, capabilities) {
    // Cr√©ation session WebDriver
  }
}
```

#### 2.3 Extraction du LogManager
```javascript
// SHARED/libs/logger/
class LogManager {
  constructor() {
    this.streams = new Map();
    this.aggregator = new LogAggregator();
  }

  addSource(name, stream) {
    // Ajout d'une source de logs
  }

  query(filters) {
    // Requ√™te sur les logs
  }

  stream(callback) {
    // Streaming temps r√©el
  }
}
```

### Phase 3: Cr√©ation de l'Orchestrateur (Semaine 3-4)
**Objectif**: Centraliser la coordination

#### 3.1 Core Orchestrator
```javascript
// ORCHESTRATOR/src/core/Orchestrator.js
class Orchestrator {
  constructor() {
    this.deviceManager = new DeviceManager();
    this.sessionManager = new SessionManager();
    this.projectLoader = new ProjectLoader();
    this.queue = new TaskQueue();
  }

  async executeProject(deviceId, projectName, config) {
    // Logique d'orchestration principale
    const device = await this.deviceManager.get(deviceId);
    const project = await this.projectLoader.load(projectName);
    const session = await this.sessionManager.create(device, project);

    return this.queue.enqueue({
      type: 'PROJECT_EXECUTION',
      session,
      project,
      config
    });
  }
}
```

#### 3.2 API REST
```javascript
// ORCHESTRATOR/src/api/routes.js
router.post('/devices/:id/execute', async (req, res) => {
  const { projectName, config } = req.body;
  const taskId = await orchestrator.executeProject(
    req.params.id,
    projectName,
    config
  );
  res.json({ taskId, status: 'queued' });
});
```

#### 3.3 WebSocket Events
```javascript
// ORCHESTRATOR/src/websocket/events.js
io.on('connection', (socket) => {
  // Streaming des logs
  logManager.stream((log) => {
    socket.emit('log', log);
  });

  // Updates de statut
  orchestrator.on('status', (update) => {
    socket.emit('status', update);
  });
});
```

### Phase 4: Refonte de l'UI (Semaine 4-5)
**Objectif**: Interface moderne et d√©coupl√©e

#### 4.1 Migration vers React/Vue
```jsx
// UI/src/renderer/App.jsx
function App() {
  const { devices, sessions } = useOrchestrator();

  return (
    <Layout>
      <Sidebar>
        <DeviceList devices={devices} />
      </Sidebar>
      <Main>
        <ControlPanel />
        <LogViewer />
        <MetricsDashboard />
      </Main>
    </Layout>
  );
}
```

#### 4.2 State Management
```javascript
// UI/src/renderer/stores/deviceStore.js
const useDeviceStore = create((set, get) => ({
  devices: new Map(),
  selectedDevice: null,

  selectDevice: (id) => set({ selectedDevice: id }),
  updateDevice: (id, data) => {
    const devices = new Map(get().devices);
    devices.set(id, { ...devices.get(id), ...data });
    set({ devices });
  }
}));
```

#### 4.3 Composants R√©utilisables
```jsx
// UI/src/renderer/components/DeviceCard/index.jsx
export function DeviceCard({ device, onStart, onStop }) {
  return (
    <Card>
      <DeviceInfo {...device} />
      <DeviceStatus status={device.status} />
      <DeviceControls
        onStart={() => onStart(device.id)}
        onStop={() => onStop(device.id)}
        disabled={device.status === 'running'}
      />
      <DeviceMetrics metrics={device.metrics} />
    </Card>
  );
}
```

### Phase 5: Modularisation des Projets (Semaine 5-6)
**Objectif**: Projets pluggables et isol√©s

#### 5.1 Structure Standard des Projets
```javascript
// PROJECTS/HINGE/index.js
module.exports = {
  name: 'HINGE',
  version: '1.0.0',

  flows: {
    onboarding: require('./flows/onboarding'),
    accountCreation: require('./flows/account-creation'),
    interaction: require('./flows/interaction')
  },

  providers: {
    sms: require('./providers/sms'),
    email: require('./providers/email'),
    proxy: require('./providers/proxy')
  },

  config: require('./config')
};
```

#### 5.2 Interface de Projet
```javascript
// SHARED/types/IProject.js
interface IProject {
  name: string;
  version: string;

  initialize(config: ProjectConfig): Promise<void>;
  execute(session: Session, params: ExecutionParams): Promise<Result>;
  cleanup(): Promise<void>;

  flows: Map<string, IFlow>;
  providers: Map<string, IProvider>;
}
```

#### 5.3 Chargeur Dynamique
```javascript
// ORCHESTRATOR/src/core/ProjectLoader.js
class ProjectLoader {
  async load(projectName) {
    const projectPath = path.join(PROJECTS_DIR, projectName);
    const project = require(projectPath);

    // Validation
    this.validateProject(project);

    // Initialisation
    await project.initialize(this.config);

    return project;
  }
}
```

### Phase 6: Infrastructure et DevOps (Semaine 6-7)
**Objectif**: Robustesse et automatisation

#### 6.1 Scripts d'Installation
```bash
#!/bin/bash
# INFRASTRUCTURE/scripts/setup.sh

echo "üöÄ Installation de la plateforme d'automatisation iOS"

# V√©rification des pr√©requis
check_prerequisites() {
  command -v node >/dev/null 2>&1 || { echo "Node.js requis"; exit 1; }
  command -v npm >/dev/null 2>&1 || { echo "npm requis"; exit 1; }
  command -v appium >/dev/null 2>&1 || { echo "Appium requis"; exit 1; }
}

# Installation des d√©pendances
install_dependencies() {
  npm install
  npx lerna bootstrap
}

# Configuration initiale
initial_setup() {
  mkdir -p data/logs
  mkdir -p data/sessions
  cp config/default.json config/local.json
}

check_prerequisites
install_dependencies
initial_setup

echo "‚úÖ Installation termin√©e"
```

#### 6.2 Health Checks
```javascript
// ORCHESTRATOR/src/monitoring/HealthChecker.js
class HealthChecker {
  async check() {
    const checks = await Promise.all([
      this.checkAppium(),
      this.checkDevices(),
      this.checkPorts(),
      this.checkDiskSpace()
    ]);

    return {
      healthy: checks.every(c => c.healthy),
      checks
    };
  }

  async checkAppium() {
    try {
      const response = await axios.get('http://localhost:4723/status');
      return { name: 'appium', healthy: true, details: response.data };
    } catch (error) {
      return { name: 'appium', healthy: false, error: error.message };
    }
  }
}
```

#### 6.3 CI/CD Pipeline
```yaml
# .github/workflows/ci.yml
name: CI

on: [push, pull_request]

jobs:
  test:
    runs-on: macos-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v2
        with:
          node-version: '20'

      - name: Install dependencies
        run: |
          npm ci
          npx lerna bootstrap

      - name: Run tests
        run: npm test

      - name: Build
        run: npm run build

      - name: E2E tests
        run: npm run test:e2e
```

### Phase 7: Tests et Validation (Semaine 7-8)
**Objectif**: Assurance qualit√©

#### 7.1 Tests Unitaires
```javascript
// TESTS/unit/DeviceManager.test.js
describe('DeviceManager', () => {
  let deviceManager;

  beforeEach(() => {
    deviceManager = new DeviceManager();
  });

  test('should detect connected devices', async () => {
    const devices = await deviceManager.scan();
    expect(devices).toBeInstanceOf(Array);
  });

  test('should allocate unique ports', async () => {
    const port1 = await deviceManager.allocatePort();
    const port2 = await deviceManager.allocatePort();
    expect(port1).not.toBe(port2);
  });
});
```

#### 7.2 Tests d'Int√©gration
```javascript
// TESTS/integration/orchestrator.test.js
describe('Orchestrator Integration', () => {
  test('should execute project end-to-end', async () => {
    const orchestrator = new Orchestrator();
    const result = await orchestrator.executeProject(
      'test-device',
      'HINGE',
      { accounts: 1 }
    );

    expect(result.status).toBe('completed');
    expect(result.accounts).toBe(1);
  });
});
```

#### 7.3 Tests de Performance
```javascript
// TESTS/performance/load.test.js
import http from 'k6/http';
import { check } from 'k6';

export let options = {
  stages: [
    { duration: '2m', target: 10 }, // Mont√©e √† 10 devices
    { duration: '5m', target: 10 }, // Maintien
    { duration: '2m', target: 0 },  // Descente
  ],
};

export default function() {
  let response = http.post('http://localhost:3000/execute', {
    device: 'virtual-device',
    project: 'HINGE'
  });

  check(response, {
    'status is 200': (r) => r.status === 200,
    'response time < 500ms': (r) => r.timings.duration < 500,
  });
}
```

## üìä Crit√®res de Succ√®s

### M√©triques Techniques
- ‚úÖ Temps de d√©marrage < 5s
- ‚úÖ Latence UI < 100ms
- ‚úÖ Support 20+ appareils simultan√©s
- ‚úÖ Recovery time < 30s apr√®s crash
- ‚úÖ Code coverage > 80%

### M√©triques M√©tier
- ‚úÖ R√©duction du temps de setup de 90%
- ‚úÖ Augmentation du taux de succ√®s de 40%
- ‚úÖ R√©duction des interventions manuelles de 75%
- ‚úÖ Temps d'ajout d'un nouveau projet < 1h

## üö® Risques et Mitigations

| Risque | Impact | Probabilit√© | Mitigation |
|--------|--------|-------------|------------|
| Breaking changes | √âlev√© | Moyen | Tests de r√©gression complets |
| Performance d√©grad√©e | Moyen | Faible | Benchmarks continus |
| Complexit√© accrue | Moyen | Moyen | Documentation et formation |
| R√©sistance au changement | Faible | Moyen | Migration progressive |

## üìÖ Timeline Globale

```
Semaine 1  : Pr√©paration et audit
Semaine 2-3: Extraction des modules
Semaine 3-4: Cr√©ation orchestrateur
Semaine 4-5: Refonte UI
Semaine 5-6: Modularisation projets
Semaine 6-7: Infrastructure
Semaine 7-8: Tests et validation
Semaine 8  : D√©ploiement progressif
```

## ‚úÖ Checklist de Migration

### Avant de commencer
- [ ] Backup complet du code actuel
- [ ] Documentation de l'existant
- [ ] Environnement de test isol√©
- [ ] Plan de rollback

### Pendant la migration
- [ ] Tests continus
- [ ] Documentation mise √† jour
- [ ] Communication r√©guli√®re
- [ ] Validation par √©tapes

### Apr√®s la migration
- [ ] Monitoring renforc√©
- [ ] Formation utilisateurs
- [ ] Optimisations
- [ ] Retour d'exp√©rience

## üéØ Prochaines √âtapes Imm√©diates

1. **Cr√©er la structure de base du monorepo**
2. **Extraire le DeviceManager en module ind√©pendant**
3. **Cr√©er l'API REST basique de l'orchestrateur**
4. **Migrer un flow simple comme POC**
5. **Valider avec un test end-to-end**

Cette migration progressive permet de:
- Minimiser les risques
- Valider √† chaque √©tape
- Maintenir le syst√®me op√©rationnel
- Apprendre et ajuster en cours de route